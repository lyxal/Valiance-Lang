+ `add` ∫[Number, Number; Number] => x + y
+ `concat` ∫[String, String; String] => x + y
- `minus` ∫[Number, Number; Number] => x - y
- `re-remove` ∫[String, String; String] => x.replace(y.pattern, '')
- `filter` ∫<T>[T+, ∫[T; Number]; T+] => x.filter(y)
* `times` ∫[Number, Number; Number] => x * y
* `str-repeat` ∫[String, Number; String] => x.repeat(y)
* `map` ∫<T, U>[T+, ∫[T; U]; U+] => x.map(y)
/ `div` ∫[Number, Number; Number] => x / y
/ `re-split` ∫[String, String; String+] => x.split(y.pattern)
/ `fold` ∫<T>[T+, ∫[T, T...; T]; T] => reduce x by y
% `mod` ∫[Number, Number; Number] => x % y
. `dup` ∫[^Any; Any, Any] => Duplicate the top element of the stack
; `swap` ∫[Any, Any; Any, Any] => Swap the top two elements of the stack
_ `pop` ⨚[Any] => Pop x from the stack
^ `pow` ∫[Number, Number; Number] => x ** y
\ `intdiv` ∫[Number, Number; Number] => x // y
\ `re-match` ∫[String, String; String] => x.match(y.pattern)
\ `scan` ∫<T>[T+, ∫[T, T...; T]; T+] => x.scan(y) - Cumulative reduce
  `println` ⨚[Any] => Print x to stdout, followed by a newline
  `print` ⨚[Any] => Print x to stdout
' `peek` ∫[∫<U>[^Any...; U]; U] => Call function without popping arguments
! `factorial` ∫[Number; Number] => x!
< `lt` (`less-than`) ∫[Number, Number; Number] => x < y
                     ∫[String, String; Number] => x < y (lexicographically, unicode order)
> `gt` (`greater-than`) ∫[Number, Number; Number] => x > y
                        ∫[String, String; Number] => x > y (lexicographically, unicode order)
`==` `eq` (`equal`)  ∫<T>[T!, T!; Number] => x == y (non lists)
() `call` ∫[∫[Any...]; Any] => Call function
          ∫[@(∫[Any...]...); Any] => Call function with appropriate arguments. All overloads must have the same arity
‡ `fuse` ∫<T, U>[T, U; @(T, U)] => Create a fusion of x and y. Roughly equivalent to `~ x y`, but dynamic
⊞ `windows` ∫<T>[T+, Number; T~] => Generate all windows of size y from x
             ∫<T>[T+, Number+; T~] => Generate all windows of sizes y from x
             ∫<T>[T+, @(Number, ∫[T, T...; T]); T+] => Reduce all windows of size y.N from x by y.∫
⌷ `index` ∫<T>[T~, Number; T] => Get the yth element of x
          ∫<K,V>[§[K,V], K; V] => Get the value of key y in dictionary x
↔ `reverse` ∫<T>[T~; T~] => Reverse x
↯ `pervade` ∫<T, U>[T~, ∫[T; U]; U~] => Apply y to atomic levels in x - dig down until T can no longer be dug deeper.
↳ `yoink` ∫[; Any] => Push the top of the stack outside of the current context
⦒ `headless` ∫<T>[T~; T~] => Remove the first element of x
⦑ `tailless` ∫<T>[T~; T~] => Remove the last element of x
≡ `===` `proper-equal` (`strict-equal`) ∫[Any, Any; Number] => x === y
⊏ `enlist` ∫[Any|Any~; Any+] => Enlist x if it is not a list
⟗ `merge` ∫<T, U>[T~, U~; (T|U)~] => Append all elements of y to x
⋉ `append` ∫<T, U>[T~, U; (T|U)~] => Append y to x
⋊ `prepend` ∫<T, U>[T~, U; (T|U)~] => Prepend y to x
æ `bifuricate` ∫<T>[T~; T~, T~] => Push x, x reversed
`ι` `iota` `one` ∫[Number; Number+] => Range [1, x]
`ζ` `zeta` `zero` ∫[Number; Number+] => Range [0, x)