The array programming paradigm is decidedly not mainstream - it is oftentimes relegated to the confines of financial institutions, niche interest groups, and passionate hobbyists. A noble audience, but something that can be approved upon.

In order to determine what a mainstream array language should encompass, it is first crucial to investigate what mainstream programming languages provide that array languages do not.

1. Structured object-oriented programming. The field of programming is still dominated by the representation of the physical world as digital "objects". As such, the biggest programming languages all support some form of OOP greater than a simple namespace/key-value pairing. They also do so in a manner that isn't an apparent afterthought, rather blending naturally into the background of the language. A look at the class notation of APL shows an ugly syntax clearly not suited to the tacit nature of APL. BQN only has namespaces, without any dedicated OOP support. Uiua recently added Data Definitions, which do not match the all-in-on-tacit nature of Uiua, and act as a sort of separate addition to the language. Therefore, a mainstream array language should have OOP in mind from the get-go, rather than something added as a minor convenience after the language's goals have been established.
2. Words. A side-effect of mainstream programming languages sharing common features is that unfamiliar programs can have their behaviour at least partly inferred from the keywords and function names utilised. This is not the case with traditional array languages where obscure Unicode characters (glyphs) are king. With the exception of languages like Nial#footnote[Uiua also has keyword support, however it's very clearly intended as an ascii-only aide rather than a design statement. This is evident from the fact that the online interpreter, by default, automatically "formats" keywords into symbols upon running programs. Additionally, the community preference is also to use glyphs over literate keywords.], a codebase written in any major array language will end up looking like a malformed hex dump. Therefore, a mainstream array language should promote keywords as a design choice rather than an addition. However, there is still merit to glyph usage, as a single character can sometimes be more suitable than a long keyword [1]. In this way, a healthy balance of glyph and keyword is an appropriate intermediate between mainstream and array traditions.
3. Static typing. In recent times, type safe programs have become important principles of production-ready software solutions. And for good reason - anyone who has used JavaScript or Python knows that there are many places dynamic typing is a hindrance. The rise of TypeScript as a statically typed alternative to JavaScript, and the popularity of type annotations in Python should serve as indications that static typing is the current flavour of mainstream programming. Array languages have a distinct lack of static typing, oftentimes because there are no types outside of "Number" and "Array" (OOP as an afterthought after all). However, for an array language with allowances for user-defined types to be passed around as if they were numbers or arrays, static typing absolutely makes sense, and would be crucial for mainstream success.
4. Flexible collection structures. In traditional array languages, there exists an "array model" which forms the basis of how arrays are structured. Given arrays are the primary (and usually only) collection structure, the array model dictates how data is shaped. Arrays are usually forced to be rectangular, meaning any nested arrays need to have the same shape. This makes mathematical sense, and can lead to some algorithmic optimisations, but has a fundamental problem - life rarely fits into a neatly shaped box, and "rugged" lists are commonplace in programming [2]. As such, array languages come up with all sorts of solutions to fit a ragged list into a square hole. For example, APL utilises a "nested array" approach where rugged lists are a sort of scalar/list hybrid - counting as a scalar for shape, but as a list for pervasiveness. Another example is how Uiua uses "boxes" to allow for unequal array sizes (and types) to coexist under a single box type. However, these implementations - and quite possibly any attempt at working rugged lists into a rectangular array model - are not without their flaws and ergonomic issues. The nested array model can be quite surprising if not expected (it's an accepted opinion that the model has problems), and the box model requires extra thought about whether an operation should used a boxed version or a non-boxed version (e.g. should the unboxing version of a modifier be utilised or not [3]) Therefore, a mainstream array language would opt for a more natural list model, foregoing the theoretical benefits of a rectangular array model (as well as breaking from the traditions of array languages - something bound to go over well with all proponents of the array programming community) for the appeal of simplicity.
5. Readable programs. This one requires a bit of context. Readable here is not referring to the subjective nature of whether a programming language is "readable" - what one person considers natural, another person will find cryptic - but rather a measure relative to the current standard of array programming languages. By this, I mean the deeply entrenched obsession with writing tacit code. While not a problem unique to array languages - Haskell exists - the elevation of tacit above all other forms of programming is amplified within the world of array programming. There is no denying that tacit programming is a beneficial style of programming - sometimes it is much more natural to write something as the composition of functions than it is to spend many lines of code performing variable maintenance. However, tacit is often taken too far. In traditional Iversonian array languages, tacit is expressed through forks and trains, leading to snippets of code that perform complex tasks in exponentially less keystrokes than imperative programming. Short code is a noble goal, but outside of code golf, it can be a hindrance and a code smell. Say a new team member wanted to work on a codebase written with tacit snippets all over the place. In addition to learning how the business logic  needs to work for the codebase, the new programmer also neds to spend time deciphering the forks and trains, and ensuring that any added glyphs do not break the chaining. In this way, an overfocus on tacit leads to more work for everyone who is not already deeply familiar with the code. And that's assuming that the original programmer is able to decipher the tacit code they wrote. Some languages take steps to improve upon this problem, like Uiua which utilses a stack based model for its tacit. This is an immediate improvement, and one that can be copied (not that Uiua is unique in doing tacit through the stack based model - stacks are inherently tacit - it's that it is the first popular [4] such array language). But Uiua takes tacit too far in a different way. In striving to be fully tacit, Uiua does not permit non-tacit conveniences like local variables and normal style OOP (as described earlier). While these features are (evidently) not required for a programming language, their exclusion as a by-product of tacit reduces opportunities for mainstream appeal. Therefore, a mainstream array language should allow for mainstream conveniences without sacrificing readability either.

While this list of components is not exhaustive (there are many other reasons mainstream languages are mainstream, ranging from funding/promotion to other desired traits like memory safety), the 5 listed above are the traits usually lacking in array languages. They serve as design goals for an array language that has every chance of becoming mainstream even against the odds of utilising a non-mainstream programming paradigm. Array programming has the potential to be a major breakthrough in the way programs are written, but it needs to have a representative that knows how to dress up for the masses.

[1]: As much as I vibe with Nial, it demonstrates that _too many_ keywords in a program is also not neccesarily the best, especially if using infix notation unfamiliar to normal imperative languages.
[2]: Even Uiua's language creator admits this, writing that "I've come to the conclusion that nested arrays are a necessary pest. The data we work with is often nested or ragged" ("https://www.uiua.org/blog/what-will-1-look-like")
[3]: It's funny how the cognitive load of boxes needs to be managed when so many language decisions like removing first class functions and introducing planet notion focused on _reducing_ cognitive load. Kei has said he'd like box ergonomics to be better, but I don't know if there'll ever be something that feels just right given the current ideological trajectory of the Uiua programming language.
[4]: Popular was chosen for a reason - Uiua is _not_ the first stack based array language - there have been others stuck in the realm of code golf that haven't seen the same successes.